<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Closures - Demystifying Asynchronous Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lifting the magic, one abstraction at a time">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="../index.html">Introduction</a></li><li class="expanded "><a href="../chapter_1/index.html"><strong aria-hidden="true">1.</strong> Towards less blocking pastures</a></li><li><ol class="section"><li class="expanded "><a href="../chapter_1/iterators.html"><strong aria-hidden="true">1.1.</strong> Iterators</a></li><li class="expanded "><a href="../chapter_1/closures.html" class="active"><strong aria-hidden="true">1.2.</strong> Closures</a></li><li class="expanded "><a href="../chapter_1/iterators_are_closures.html"><strong aria-hidden="true">1.3.</strong> Iterators are closures are iterators</a></li><li class="expanded "><a href="../chapter_1/async_rust.html"><strong aria-hidden="true">1.4.</strong> The case for asynchronous Rust</a></li></ol></li><li class="expanded "><a href="../chapter_2/index.html"><strong aria-hidden="true">2.</strong> Chapter II</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Demystifying Asynchronous Rust</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/teh-cmc/rust-async" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#12-closures" id="12-closures">1.2. Closures</a></h2>
<p>While iterators are pretty straightforward both from a usage and an implementation standpoint, closures are anything but.<br />
In fact, I'd argue they're one of the most complex pieces of &quot;standard&quot; synchronous Rust.<br />
Their very expressive nature, thanks to a lot of magical sugar exposed by the compiler, make them a prime tool to push the type system into very complex corners, whether voluntarily.. or not.</p>
<p>Closures also happen to be the cornerstone of any serious asynchronous codebase, where their incidental complexity tends to skyrocket as a multitude of issues specific to asynchronous &amp; multi-threaded code join in on the party.</p>
<h3><a class="header" href="#12a-a-better-bounds" id="12a-a-better-bounds">1.2.a. A better <code>Bounds</code></a></h3>
<p>We'll kick off this section by turning our <code>Bounds</code> filter into a filter of.. well, anything, really:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Filter&lt;I, P&gt; {
    inner: I,
    predicate: P,
}

impl&lt;I, P&gt; Filter&lt;I, P&gt; {
    pub fn new(inner: I, predicate: P) -&gt; Self {
        Self { inner, predicate }
    }
}

impl&lt;I, P&gt; Iterator for Filter&lt;I, P&gt;
where
    I: Iterator,
    P: FnMut(&amp;I::Item) -&gt; bool,
{
    type Item = I::Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.inner.next() {
                Some(v) if (self.predicate)(&amp;v) =&gt; return v.into(),
                Some(_) =&gt; {}
                None =&gt; return None,
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Might as well provide an extension for it too:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait FilterExt: Iterator
where
    Self: Sized,
{
    fn filter_with&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool,
    {
        Filter::new(self, predicate)
    }
}

impl&lt;I: Iterator&gt; FilterExt for I {}
<span class="boring">}
</span></code></pre></pre>
<p>Lo and behold:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut it = Range::new(1usize, 20, 1).filter_with(|&amp;v| v &gt;= 5 &amp;&amp; v &lt; 8);
assert_eq!(Some(5), it.next());
assert_eq!(Some(6), it.next());
assert_eq!(Some(7), it.next());
assert_eq!(None, it.next());
<span class="boring">}
</span></code></pre></pre>
<p>Yep, that does it.</p>
<p>So that's nice and all but.. how does our final state-machine ends up being implemented?</p>
<pre><code class="language-sh">$ cargo rustc --lib -- --test -Zprint-type-sizes
# [...]
`Filter&lt;Range&lt;usize&gt;, [closure]&gt;`: 24 bytes, alignment: 8 bytes
`Range&lt;usize&gt;`: 24 bytes, alignment: 8 bytes
</code></pre>
<p>Wait, wat? How come a monomorphized <code>Filter&lt;Range&lt;usize&gt;, &lt;[closure]&gt;&gt;</code> is the same size as a <code>Range&lt;usize&gt;</code>?</p>
<p>The only way this is possible is if storing our closure costs a whopping 0 byte which.. doesn't seem plausible?<br />
Let's take a minute to try and understand what's going on here.</p>
<h3><a class="header" href="#12b-whats-a-closure-anyway" id="12b-whats-a-closure-anyway">1.2.b. What's a closure, anyway?</a></h3>
<p>A closure is nothing but a structure (its captured environment) that implements one (or more) trait from the <code>Fn*</code> family of traits (<code>FnOnce</code>, <code>FnMut</code> and <code>Fn</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>What that structure looks like will vary depending on the environment that the closure captures.<br />
For that reason, every closure has a different type (!), and every closure requires a proper structure declaration in order to carry its state.<br />
Obviously, having to manually declare a proper definition for your closure's captured state every time would be way too cumbersome, to the point of rendering closures completely useless.</p>
<p>To cope with that, the compiler automatically generates an appropriate anonymous structure every time you create a closure.<br />
Consider e.g. the following code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 42;
let b = 100;
let f = |v: i32| v + a + b;
<span class="boring">}
</span></code></pre></pre>
<p>Behind the scenes, the compiler will generate something along these lines to store the state of the closure:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct __anonymous_e3b0105&lt;'a&gt; {
    a: &amp;'a i32,
    b: &amp;'a i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, if we instead had specified that we wanted to <em>move</em> (i.e. take ownership of) the captured variables into the closure's state rather than just keep references to them, i.e. this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 42;
let b = 100;
let f = move |v: i32| v + a + b;
<span class="boring">}
</span></code></pre></pre>
<p>would then turn into this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct __anonymous_e3b0105 {
    a: i32,
    b: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Don't take my word for it, ask the compiler:</p>
<pre><code class="language-sh">$ cargo rustc --lib -- --test -Zprint-type-sizes
# [...]
`[closure&lt;a:&amp;i32, b:&amp;i32&gt;]`: 16 bytes ## let f = |v: i32| v + a + b;
`[closure&lt;a:i32, b:i32&gt;]`: 8 bytes ## let f = move |v: i32| v + a + b;
</code></pre>
<p>And so that covers the issue of generating an appropriate structure to hold the state (or captured environment) of the closure.<br />
What about implementing <code>FnOnce</code>/<code>FnMut</code>/<code>Fn</code> on that generated structure, though?</p>
<p>Similarly, manually providing the right <code>Fn*</code> trait(s) implementations for each and every closure would be unmanageable, and so, once again, the compiler got our backs and does it for us.<br />
To see what these implementations might look like, we could either A) have a look at the generated IR and/or assembly, or better yet, B) handcraft our own closure out of thin air.</p>
<p>Let's go with option B.</p>
<h3><a class="header" href="#12c-handcrafted-closures" id="12c-handcrafted-closures">1.2.c. Handcrafted closures</a></h3>
<p>Remember we had this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 42;
let b = 100;
let f = |v: i32| v + a + b;
<span class="boring">}
</span></code></pre></pre>
<p>Now what we'd like to do is to implement <code>f</code> without any help from the compiler.</p>
<p>First, we need to store our state somewhere. In this case, the capture is made by reference and so our structure should reflect that:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MyClosure&lt;'a&gt; {
    a: &amp;'a i32,
    b: &amp;'a i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, we need to implement the right <code>Fn*</code> trait(s). This part is a bit trickier.</p>
<hr />
<h3><a class="header" href="#aside-the-many-many-faces-of-closures" id="aside-the-many-many-faces-of-closures">Aside: The many, many faces of Closures</a></h3>
<p>When you create a closure, the compiler will always try to implement the most versatile of all the <code>Fn*</code> traits that it can, i.e. the trait that will allow you to use the closure in as many situations as possible.<br />
Whether or not a <code>Fn*</code> trait can be implemented depends solely on how the closure interacts with its state.</p>
<p><strong><code>FnOnce</code></strong></p>
<p>If the closure moves anything out of its state, then its state (i.e. <code>self</code>) will have to be <em>consumed</em> to perform the call, in which case the only trait that it can implement is <code>FnOnce</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn call_once(self, args: Args) -&gt; Self::Output // `self`
<span class="boring">}
</span></code></pre></pre>
<p>/!\ A common misconception is that whether a closure is or isn't <code>FnOnce</code> has anything to do with the use of <code>move</code>. It does <em><strong>not</strong></em>.</p>
<p>This closure is <code>Fn</code>, as demonstrated by the multiple calls to it:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 42;
let b = 100;
let f: &amp;dyn Fn(i32) -&gt; i32 = &amp;|v: i32| v + a + b; // Compiles!
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
<span class="boring">}
</span></code></pre></pre>
<p>And so is this one:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 42;
let b = 100;
let f: &amp;dyn Fn(i32) -&gt; i32 = &amp;move |v: i32| v + a + b; // Compiles still!
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
<span class="boring">}
</span></code></pre></pre>
<p>It doesn't matter that the second closure moves <code>a</code> &amp; <code>b</code> into its state (well it certainly matters to the enclosing scope, which can't refer to these variables anymore, but that's besides the point).</p>
<p>What matters is how the closure interacts with its state when it gets called.<br />
In the example above, that interaction is just a read through a reference, and so a shared reference to the state (i.e. <code>&amp;self</code>) is enough to perform the call: the compiler makes sure that this closure is <code>Fn</code>.</p>
<p>Now if you were to do this on the other hand..:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MyNonCopyType(i32);
let a = MyNonCopyType(42);
let b = MyNonCopyType(100);
let f = |v: i32| {
    let ret = v + a.0 + b.0;
    drop(a);
    ret
};
assert_eq!(150, f(8)); // really `FnOnce::call_once(f, (8,))`
// assert_eq!(150, f(8)); // Won't compile: value used after move
<span class="boring">}
</span></code></pre></pre>
<p>Now that's a big no-no. <code>drop(a)</code> moves <code>a</code> out of the closure's state, and so the only way to perform the call is to consume its state (i.e. <code>self</code>). The compiler makes sure that this closure is <code>FnOnce</code>, and thus uncommenting the second call won't compile.<br />
Notice that we're even capturing <code>a</code> &amp; <code>b</code> by reference in this case and it doesn't matter, because this has nothing to do with the use of <code>move</code>!</p>
<p><strong><code>FnMut</code></strong></p>
<p>If the closure needs to modify its state during execution, but doesn't need to move anything out of it, then it's gonna need a mutable reference to <code>self</code> to perform the call; i.e. it implements <code>FnMut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output // `&amp;mut self`
<span class="boring">}
</span></code></pre></pre>
<p>Of course, if our <code>FnMut</code> closure can be called N times, then it would certainly make sense that we should be able to call it only once. Indeed, <code>FnMut</code> is a supertrait of <code>FnOnce</code> (hence <code>FnMut&lt;Args&gt;: FnOnce&lt;Args&gt;</code>).<br />
This is easier to visualize with an example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn run_once&lt;F&gt;(f: F) -&gt; i32 // `f` isn't even marked as `mut`..
where
    F: FnOnce() -&gt; i32,
{
    f() // ..but `self` is really `&amp;mut self`, because tricks!
}

fn run_mut&lt;F&gt;(mut f: F) -&gt; i32
where
    F: FnMut() -&gt; i32,
{
    f()
}

let mut a = 10;
let mut fmut = || {
    a += 1;
    a
};

assert_eq!(11, run_once(&amp;mut fmut));
assert_eq!(12, run_once(&amp;mut fmut));
assert_eq!(13, run_mut(&amp;mut fmut));
assert_eq!(14, run_mut(&amp;mut fmut));
<span class="boring">}
</span></code></pre></pre>
<p>And the reason why this works is because of this little jewel in libcore:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
impl&lt;A, F: ?Sized&gt; FnOnce&lt;A&gt; for &amp;mut F
where
    F: FnMut&lt;A&gt;,
{
    type Output = F::Output;
    extern &quot;rust-call&quot; fn call_once(self, args: A) -&gt; F::Output {
        (*self).call_mut(args)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>Fn</code></strong></p>
<p>Finally, if the closure just reads from its environment without ever modifying it, all it's gonna need to perform a call is a shared refence to <code>self</code>: it implements <code>Fn</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn call(&amp;self, args: Args) -&gt; Self::Output // `&amp;self`
<span class="boring">}
</span></code></pre></pre>
<p>Once again, no reason why a <code>Fn</code> closure couldn't behave as a <code>FnMut</code>; if a closure can be executed N times while modifying its state, it certainly can be executed N times without modifying it (hence <code>Fn&lt;Args&gt;: FnMut&lt;Args&gt;</code>).<br />
And, as we know, if a closure is <code>FnMut</code>, then it is <code>FnOnce</code> too:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn run_once&lt;F&gt;(f: F, b: i32) -&gt; i32
where
    F: FnOnce(i32) -&gt; i32,
{
    f(b)
}

fn run_mut&lt;F&gt;(mut f: F, b: i32) -&gt; i32
where
    F: FnMut(i32) -&gt; i32,
{
    f(b)
}

fn run&lt;F&gt;(f: F, b: i32) -&gt; i32
where
    F: Fn(i32) -&gt; i32,
{
    f(b)
}

let a = 10;
let f = |b: i32| a + b;

assert_eq!(52, run_once(&amp;f, 42));
assert_eq!(52, run_once(&amp;f, 42));
assert_eq!(52, run_mut(&amp;f, 42));
assert_eq!(52, run_mut(&amp;f, 42));
assert_eq!(52, run(&amp;f, 42));
assert_eq!(52, run(&amp;f, 42));
<span class="boring">}
</span></code></pre></pre>
<p>Once again, we can thank libcore for this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
impl&lt;A, F: ?Sized&gt; FnOnce&lt;A&gt; for &amp;F
where
    F: Fn&lt;A&gt;,
{
    type Output = F::Output;

    extern &quot;rust-call&quot; fn call_once(self, args: A) -&gt; F::Output {
        (*self).call(args)
    }
}

#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
impl&lt;A, F: ?Sized&gt; FnMut&lt;A&gt; for &amp;F
where
    F: Fn&lt;A&gt;,
{
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: A) -&gt; F::Output {
        (**self).call(args)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And that concludes our aside regarding the <code>Fn*</code> family of traits.</p>
<hr />
<p>Back to our original business.<br />
We were wondering how to implement the right <code>Fn*</code> traits for our closure's state:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MyClosure&lt;'a&gt; {
    a: &amp;'a i32,
    b: &amp;'a i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Our closure only references its environment: it never modifies it nor does it ever move it somewhere else, therefore the most versatile implementation that we can provide is <code>Fn</code>, which should allow it to be run pretty much anywhere.<br />
As we've seen, <code>Fn</code> is a supertrait of <code>FnMut</code> is a supertrait of <code>FnOnce</code>, and so we need to implement the entire family tree in this case:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; FnOnce&lt;(i32,)&gt; for MyClosure&lt;'a&gt; {
    type Output = i32;

    extern &quot;rust-call&quot; fn call_once(self, _args: (i32,)) -&gt; Self::Output {
        unreachable!()
    }
}

impl&lt;'a&gt; FnMut&lt;(i32,)&gt; for MyClosure&lt;'a&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, _args: (i32,)) -&gt; Self::Output {
        unreachable!()
    }
}

impl&lt;'a&gt; Fn&lt;(i32,)&gt; for MyClosure&lt;'a&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, (v,): (i32,)) -&gt; Self::Output {
        v + self.a + self.b
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Lo and behold, we've got ourselves a closure:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 42;
let b = 100;
let f = MyClosure { a: &amp;a, b: &amp;b };
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
assert_eq!(150, f(8)); // really `Fn::call(&amp;f, (8,))`
<span class="boring">}
</span></code></pre></pre>
<p>So that's great and all, but it still doesn't explain why this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut it = Range::new(1usize, 20, 1).filter_with(|&amp;v| v &gt;= 5 &amp;&amp; v &lt; 8);
assert_eq!(Some(5), it.next());
assert_eq!(Some(6), it.next());
assert_eq!(Some(7), it.next());
assert_eq!(None, it.next());
<span class="boring">}
</span></code></pre></pre>
<p>yields this:</p>
<pre><code>`Filter&lt;Range&lt;usize&gt;, [closure]&gt;`: 24 bytes, alignment: 8 bytes
`Range&lt;usize&gt;`: 24 bytes, alignment: 8 bytes
</code></pre>
<p>I.e. how a <code>Range&lt;usize&gt;</code> happens to be the same size as a <code>Filter&lt;Range&lt;usize&gt;</code>.
The first thing to take note of is that this closure never captures anything, and so it'd make sense that its state is 0-byte sized:</p>
<pre><code class="language-sh">$ cargo rustc --lib -- --test -Zprint-type-sizes
# [...]
`[closure]`: 0 bytes, alignment: 1 bytes
</code></pre>
<p>In fact, the compiler won't even bother generating an anonymous structure for it, and so our closure lives entirely in the code section of the executable: it has no associated data.<br />
Effectively, it is just a plain function pointer:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let _f: fn(usize) -&gt; bool = |v: usize| v &gt;= 5 &amp;&amp; v &lt; 8; // compiles!
<span class="boring">}
</span></code></pre></pre>
<p>That explains why our closure is 0 byte, but it certainly doesn't explain why a <code>Filter&lt;Range&lt;usize&gt;, [closure]&gt;</code> is the same size as a <code>Range&lt;usize&gt;</code>. Even if the closure itself is 0 byte, <code>Filter</code> still has has to hold a function pointer to the code portion of the closure, which is 8 bytes on a 64bit platform such as mine.<br />
What are we missing?</p>
<p>Consider the following code where we instantiate a <code>Filter</code> using an empty closure (i.e. an anonymous function):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;empty_closure&quot;)]
fn empty_closure() {
    let range = Range::new(10usize, 20, 1).into_iter();
    assert_eq!(24, size_of_val(&amp;range));

    let mut filter = range.filter_with(|&amp;v| v &gt;= 7 &amp;&amp; v &lt; 15);
    assert_eq!(24, size_of_val(&amp;filter)); // 24 bytes!

    let x = filter.next();
    println!(&quot;{:?}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>To understand what's actually going on here, we need to have a direct look at the assembly generated for our <code>Filter</code>'s <code>.next</code> method:</p>
<pre><code class="language-sh">$ cargo asm --features empty_closure \
            --asm-style att \
            --build-type debug \
            '&lt;chapter_1::Filter&lt;I,P&gt; as core::iter::traits::iterator::Iterator&gt;::next'
</code></pre>
<p>We'll specifically focus on the indirect call to the predicate (i.e. <code>(self.predicate)(&amp;v)</code>):</p>
<pre><code class="language-assembly">;; (self.predicate)(&amp;v)
leaq    64(%rsp), %rax
movq    %rax, 80(%rsp)
movq    32(%rsp), %rdi
movq    80(%rsp), %rax
movq    %rax, 88(%rsp)
movq    88(%rsp), %rsi
callq   closure_filters::empty_closure::{{closure}}
movb    %al, 31(%rsp)
</code></pre>
<p>Don't worry too much about all these <code>mov</code> instructions for now, the only relevant piece of information is in fact written in plain english: <code>callq closure_filters::empty_closure::{{closure}}</code>.<br />
The compiler has completely optimized out the indirect call through <code>self.predicate</code>: the address of the closure is hardcoded right there into the <code>.next</code> method!<br />
We have monomorphization to thank for that, it generated a <code>.next</code> function specialized for <code>I = Range&lt;usize&gt;</code> and <code>P = [closure]</code>, where <code>[closure]</code> denotes the unique, anonymous type of our closure (remember, <em>each and every</em> closure gets its own anonymous type).<br />
Since <code>self.predicate</code> is a <code>P</code>, and the compiler knows that <code>P</code> is nothing but a function pointer (i.e. <code>P: FnMut</code>), it therefore knows that it can eliminate the runtime dispatch in favor of what we're seeing here.</p>
<p>What if our closure <em>did</em> capture some state, then?</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;capturing_closure&quot;)]
fn capturing_closure() {
    let range = Range::new(10usize, 20, 1).into_iter();
    assert_eq!(24, size_of_val(&amp;range));

    let min = 7;
    let max = 15;
    let mut filter = range.filter_with(|&amp;v| v &gt;= min &amp;&amp; v &lt; max);
    assert_eq!(40, size_of_val(&amp;filter)); // 40 bytes!

    let x = filter.next();
    println!(&quot;{:?}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>We can see here that we capture two references to <code>usize</code>, i.e. 16 bytes:</p>
<pre><code class="language-sh">$ cargo rustc --bin closure_filters --features capturing_closure -- -Zprint-type-sizes
# [...]
`[closure&lt;min:&amp;usize, max:&amp;usize&gt;]`: 16 bytes, alignment: 8 bytes
</code></pre>
<p>And so our <code>Filter&lt;Range&lt;usize&gt;, [closure&lt;&amp;usize,&amp;usize&gt;]</code> should be</p>
<pre><code class="language-sh">sizeof(Range&lt;usize&gt;) + ## 24
sizeof([closure&lt;&amp;usize,&amp;usize&gt;]) + ## 16
sizeof(&amp;dyn FnMut(&amp;I::Item) -&gt; bool) ## 8
</code></pre>
<p>i.e. 50 bytes.<br />
But of course, the same optimization applies:</p>
<pre><code class="language-sh">$ cargo rustc --bin closure_filters --features capturing_closure -- -Zprint-type-sizes
# [...]
`Filter&lt;Range&lt;usize&gt;, [closure&lt;min:&amp;usize, max:&amp;usize&gt;]&gt;`: 40 bytes, alignment: 8 bytes
</code></pre>
<p>Once again monomorphization has eliminated the extra indirection:</p>
<pre><code class="language-sh">$ cargo asm --features capturing_closure \
            --asm-style att \
            --build-type debug \
            '&lt;chapter_1::Filter&lt;I,P&gt; as core::iter::traits::iterator::Iterator&gt;::next'
</code></pre>
<pre><code class="language-assembly">;; (self.predicate)(&amp;v)
leaq    64(%rsp), %rax
movq    %rax, 80(%rsp)
movq    32(%rsp), %rax
addq    $24, %rax       ;; 24 bytes offset from the start of `Filter&lt;I, P&gt;` is `self.predicate`,
                        ;; i.e. the captured state, aka `self`.
movq    80(%rsp), %rcx
movq    %rcx, 88(%rsp)
movq    88(%rsp), %rsi
movq    %rax, %rdi
callq   closure_filters::capturing_closure::{{closure}}
movb    %al, 31(%rsp)
</code></pre>
<p>The attentive reader shall notice the two extra instructions this time: the compiler is properly setting up the stack so that our closure can access its state (which is made to point to <code>self.predicate</code>, using a 24 bytes offset).</p>
<h3><a class="header" href="#12c-usual-complications" id="12c-usual-complications">1.2.c. Usual complications</a></h3>
<p>When working in single-threaded environments, closures are usually a breathe to work with. The compiler gets to do its magic and you rarely seem to get into trouble, if at all.<br />
Once we get into async code, though, some concepts that are usually mostly invisible will start becoming very apparent as Rust compile-time safeties start kicking in.</p>
<p><strong>Higher Ranked Trait Bounds</strong></p>
<p>The first complication that I want to mention has nothing to do with neither multi-threading nor asynchronous code, but you're bound to face it at one point or another if you start digging into any closure-heavy codebase (which is true of any async codebase, so..), so I'd rather mention it in passing.</p>
<p>TL;DR, you <em>will</em> encounter this syntax at one point or another:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Notice the `for&lt;'a&gt;` in that trait bound.
fn my_func&lt;F: for&lt;'a&gt; Fn(&amp;'a str) -&gt; bool&gt;(f: F) -&gt; bool { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>which is meant to denote the higher-kindness of a lifetime trait bound, meaning that <code>&amp;str</code> cannot outlive <code>'a</code>, where <code>'a</code> is <em>any</em> lifetime, i.e. it is left unconstrained.</p>
<p>While I would love to talk about Generic Associated Types, Higher Ranked Types/Lifetimes and all that fun at some point, now is nor the time nor the place.<br />
For now, just keep in mind that this syntax exists, that you will most likely encouter it at some point, and that you'll find all the information you'll ever need in <a href="https://rust-lang.github.io/rfcs/0387-higher-ranked-trait-bounds.html">the original RFC</a> as well as in <a href="https://doc.rust-lang.org/nomicon/hrtb.html">the corresponding nomicon entry</a>.</p>
<p><strong>Auto marker traits and inferred lifetimes</strong></p>
<p>Always keep in mind that closures are just structures, and thus the usual rules regarding compound types and auto &amp; marker traits as well as lifetimes apply.<br />
I.e. the lifetime and intrinsic properties of a state-machine built up from the combination of iterators and closures will be a direct result of both its explicitly <em>and</em> implicitly captured enviroments.</p>
<p>Consider our <code>Filter</code> combinator, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let min = 5;
let max = 8;
let mut it = Range::new(1usize, 20, 1).filter_with(|&amp;v| v &gt;= min &amp;&amp; v &lt; max);
assert_eq!(Some(5), it.next());
assert_eq!(Some(6), it.next());
assert_eq!(Some(7), it.next());
assert_eq!(None, it.next());
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the resulting state-machine's (<code>it</code>) lifetime is bounded by the lifetimes of <code>min</code> &amp; <code>max</code>.<br />
Similarly, whether <code>it</code> can or cannot be moved between threads (i.e. <code>Send</code>) depends on whether <code>min</code> &amp; <code>max</code> can be sent between threads.</p>
<p>Obviously, in a state-machine as simple as this one, this won't ever cause you any trouble.<br />
In a massive asynchronous state-machine, built-up from many many parts (that may even cross module boundaries), and that will be arbitrarily moved back and forth between threads by some executor that you might or might not control, on the other hand... Let's just say that it can be easy to lose track of who requires what and for how long.</p>
<p>But, hey, that's precisely why we're using Rust in the first place!<br />
Compiler errors for these hard cases have become insanely good too, if quite verbose.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../chapter_1/iterators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../chapter_1/iterators_are_closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../chapter_1/iterators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../chapter_1/iterators_are_closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
