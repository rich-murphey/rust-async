<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The case for asynchronous Rust - Demystifying Asynchronous Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lifting the magic, one abstraction at a time">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="../index.html">Introduction</a></li><li class="expanded "><a href="../chapter_1/index.html"><strong aria-hidden="true">1.</strong> Towards less blocking pastures</a></li><li><ol class="section"><li class="expanded "><a href="../chapter_1/iterators.html"><strong aria-hidden="true">1.1.</strong> Iterators</a></li><li class="expanded "><a href="../chapter_1/closures.html"><strong aria-hidden="true">1.2.</strong> Closures</a></li><li class="expanded "><a href="../chapter_1/iterators_are_closures.html"><strong aria-hidden="true">1.3.</strong> Iterators are closures are iterators</a></li><li class="expanded "><a href="../chapter_1/async_rust.html" class="active"><strong aria-hidden="true">1.4.</strong> The case for asynchronous Rust</a></li></ol></li><li class="expanded "><a href="../chapter_2/index.html"><strong aria-hidden="true">2.</strong> Chapter II</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Demystifying Asynchronous Rust</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/teh-cmc/rust-async" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#14-the-case-for-asynchronous-rust" id="14-the-case-for-asynchronous-rust">1.4. The case for asynchronous Rust</a></h2>
<p>And with that, our little demystifying tour of iterators and closures comes to an end.<br />
So, what was the point of all of this? What do iterators and closures have to do with anything?</p>
<p>Actually, beyond iterators and closures, what we've really looked at during this chapter are the various ways of expressing state-machines using Rust's native tools.<br />
Coincidentally, a lot (most?) of idiomatic Rust code comes down to just that: building up complex state machines by combining iterators and closures, and then polling these state-machines at the edge of the software, where errors will be dealt with properly.</p>
<p>What's with asynchronous Rust, then? What can we express in async Rust that we couldn't convey with these tools? The answer is multiplexing.. kind of.</p>
<h3><a class="header" href="#14a-what-are-we-trying-to-fix" id="14a-what-are-we-trying-to-fix">1.4.a. What are we trying to fix?</a></h3>
<p>A standard iterator will hold an entire OS thread from the time it's polled and until it yields its next value. Whether this iterator actually does something useful with that OS thread is irrelevant.<br />
Consider this over-used example of an iterator that sends a packet to a station on Mars when it gets polled, and yields a welcoming message when an answer comes back from the network:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct PingMars;

impl Iterator for PingMars {
    type Item = &amp;'static str;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        fn ping_mars() -&gt; &amp;'static str {
            use std::{thread::sleep, time::Duration};
            sleep(Duration::from_secs(2)); // simulating network
            &quot;Hello from Mars!&quot;
        }

        ping_mars().into()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Once we start polling it, this iterator will keep hold of the underlying OS thread for as long as it takes for Mars to respond.<br />
Obviously, in this case, the overwhelming majority of the CPU time will be spent idling, waiting for data from the network.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut mars_com = PingMars;
for msg in mars_com { // Blocking an entire OS thread :(
    println!(&quot;received message from Mars: {}!&quot;, msg);
}
<span class="boring">}
</span></code></pre></pre>
<p>That's the textbook case of synchronous/blocking I/O, which has been thrown around and around for the last decades.</p>
<p>But the issue isn't really confined to I/O, is it?<br />
What about a program that has to sleep, e.g. to wait for an external piece of hardware to get ready?<br />
What about a program that is stuck waiting for an intra-program signal, e.g. a channel or a mutex?</p>
<p>It seems that what we're getting at is that the issue isn't specific to I/O, but rather generalizes to any non-CPU intensive code.<br />
Actually, I'd argue that it encompasses even more than &quot;just&quot; non-CPU intensive code.</p>
<p>What if we had a state-machine that needed to do some CPU-heavy computation on every poll, but we'd still very much like for it <em>not</em> to hijack an entire OS thread until its next yield; i.e. we'd like to be able to pause the computation of a value at arbitrary points, so that another state-machine could make some progress of its own in the meanwhile.<br />
Heck, what if we were running on some kind of embedded platform that doesn't provide OS threads in the first place?</p>
<p>Consider this (ridiculously bad) Fibonacci iterator:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Fibonacci {
    cur: usize,
    until: usize,
}

impl Fibonacci {
    pub fn new(until: usize) -&gt; Self {
        Self { cur: 0, until }
    }
}

impl Iterator for Fibonacci {
    type Item = (usize, usize);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.cur &gt; self.until {
            return None;
        }
        let n = self.cur;
        self.cur += 1;

        fn fib(n: usize) -&gt; usize {
            match n {
                v if v == 0 =&gt; 0,
                v if v == 1 =&gt; 1,
                v =&gt; fib(v - 1) + fib(v - 2),
            }
        }
        (n, fib(n)).into()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For big enough values of <code>n</code>, every poll is going to take so much CPU-time to compute, maybe we'd rather let some other state-machine progress from time to time, hm?<br />
(Yes, Fibonacci is a very contrived example. Yes, memoization would be a much better solution in this case. Bear with me.)</p>
<p>The real issue here is neither blocking I/O, or non-CPU intensive code, or anything specific like that.<br />
The real issue simply is that we need a way to express <em>multiplexing</em> as part of our state-machines, and more specifically as part of our polling mechanism.</p>
<p>Question: <em>Haven't we fixed that issue already, though? Like decades ago?</em><br />
That's exactly what OS threads are for, multiplexing N programs onto M physical threads, and we've had those for who-knows how long.<br />
In fact they work so well that you can spawn millions of them without breaking a sweat on modern hardware.</p>
<p>Answer: <em>Yes, there is in fact nothing that you could express with Futures/Streams that you wouldn't be able to convey with Closures/Iterators and a bunch of good ol' OS threads.</em><br />
In fact, both Rust's stdlib and ecosystem offer very powerful tools for working with OS threads (<a href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a>) and multi-threaded iterators (<a href="https://github.com/rayon-rs/rayon"><code>rayon</code></a>); these tools should most likely always be your first weapon of choice, unless you fall into either of those two categories:</p>
<ul>
<li>You have hard performance constraints.<br />
Async code can achieve A) much better performance and B) more efficient CPU usage than OS threads thanks to the lack of context-switching overhead.<br />
At large enough scale, this will more than likely manifests itself as A) smoother tail latencies and B) much cheaper CPU bills.</li>
<li>You have hard environment constraints.<br />
What if your platform simply doesn't provide OS threads? What if it does but you cannot use them for some reason (e.g. some determinism contraints)?</li>
</ul>
<p>Of course, those gains don't come for free.<br />
As we'll see in the rest of this book, asynchronous Rust ships with a metric ton of added complexity, a tradeoff that may or may not be worth it depending on your constraints.</p>
<h3><a class="header" href="#14b-howd-we-go-about-fixing-it" id="14b-howd-we-go-about-fixing-it">1.4.b. How'd we go about fixing it?</a></h3>
<p>Let's take a minute to think about how'd we go about fixing the lack of multiplexing capability of closures and iterators.</p>
<p>In the case of the <code>PingMars</code> iterator, the solution is obvious: we would need to make use of non-blocking I/O so that we could give back control of the OS thread to the poller in case the underlying network device isn't ready yet.<br />
Somehow, we'll also need to find a way to notify the poller when the underlying device finally turns ready again, otherwise how could they know when they should start polling again?</p>
<p>For the <code>Fibonacci</code> example, we'd need a way to give control of the thread back to the poller in case the current value is taking too long to compute (for an arbitrary definition of &quot;too long&quot;).<br />
Interestingly, we don't need to ever notify the poller in this case: they're free to start polling again whenever they want, the iterator only released the OS thread for the sake of politeness anyway; i.e. it's always ready.<br />
What we're definitely going to need, though, is a way to know exactly where we stopped in the computation back when we released the OS thread, so that we can continue from that point on when the polling restarts.</p>
<p>We could go on and on, but already a pattern starts emerging here:</p>
<ul>
<li>The state-machine must be able to give back control of the OS thread to the poller, even from the middle of a polling cycle.</li>
<li>The state-machine must have a way of notifying the poller when it's a good time to start polling again.</li>
<li>The state-machine must keep track of the progress made during the last polling cycle, so that it can start again from there.</li>
</ul>
<p>Say we were to take the definition of Iterator and encode those constraints in it, we'd probably end up with something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub enum Poll&lt;T&gt; {
    Ready(Option&lt;T&gt;),
    NotReady,
}

pub struct Notifier {/* ... */}

pub trait MultiplexedIterator {
    type Item;

    /// Advances the iterator and returns the next value as a `Poll::Ready(T)`
    /// if it's ready to be yielded, otherwise returns `Poll::NotReady`.
    /// The poller is responsible for polling again and again, until an actual
    /// value can be returned.
    ///
    /// Returns `Poll::Ready(None)` when iteration is finished.
    /// Individual iterator implementations must notify the poller when it can
    /// poll again after having returned `Poll::NotReady`.
    fn next(&amp;mut self, n: Notifier) -&gt; Poll&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Guess what, we've essentially just reinvented <code>Stream</code> (..almost)!</p>
<p>When you take Closures and Iterators, and engineer multiplexing-support into them, what you get back are Futures and Streams.</p>
<h3><a class="header" href="#14c-conclusion" id="14c-conclusion">1.4.c. Conclusion</a></h3>
<p><strong>Asynchronous Rust is about expressing state-machines that can be multiplexed onto a single OS thread</strong>.</p>
<p>The main reasons to do so are A) better overall performance and B) environment constraints, at the cost of a massive increase in complexity, both from a usage and implementation standpoints.</p>
<p><code>Future</code>s and <code>Stream</code>s are logical extensions to closures and iterators, giving them the ability to be multiplexed onto a single OS thread.<br />
As we'll see, the four of them all share many of the same properties and design principles, which is why we've spent this entire chapter covering every last details of closures and iterators in the first place.</p>
<p>Iterators and closures are, as I like to say, the gateway drugs to Futures and Streams.<br />
In fact, as we'll see later in this book, these four can (and will be) all be expressed in terms of the mother of all state-machines: Generators.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../chapter_1/iterators_are_closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../chapter_2/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../chapter_1/iterators_are_closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../chapter_2/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
